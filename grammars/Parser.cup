package ch.ffhs.pm.fac.parser;

import java.util.ArrayList;
import java.util.Arrays;
import java_cup.runtime.*;
import ch.ffhs.pm.fac.instr.*;

terminal PLUS, MINUS, MUL, DIV, MOD, POW;
terminal EQUAL, NOT_EQUAL, LESS_THAN, GREATER, LESS_EQUAL, GREATER_EQUAL;
terminal ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_MUL, ASSIGN_DIVIDE;
terminal IF, ELSE, FUNC, WHILE, TERMINATOR, SEPARATOR, TRUE, FALSE, SEP;
terminal BRACKETS_LEFT, BRACKETS_RIGHT;

terminal String NUMBER;
terminal String STRING;
terminal String IDENTIFIER;

non terminal Instruction SCRIPT;
non terminal END;

non terminal ArrayList<Instruction> STATEMENT_LIST;
non terminal ArrayList<String> PARAMETER_LIST;
non terminal ArrayList<Instruction> ARGUMENT_LIST;
non terminal Instruction STATEMENT, ASSIGN_STATEMENT, BASIC_STATEMENT;
non terminal Instruction IF_STATEMENT, ELSE_STATEMENT, CONDITIONAL_STATEMENT, WHILE_STATEMENT;
non terminal Instruction FUNCTION_STATEMENT, FUNCTION_CALL_STATEMENT;
non terminal Instruction ARITHMETIC_STATEMENT, NEGATE_STATEMENT;

start with SCRIPT;
      
SCRIPT ::= STATEMENT_LIST:sl STATEMENT:s END {: RESULT = new InstructionScript(sl, s); :};
               
STATEMENT_LIST ::= {: RESULT = new ArrayList<Instruction>(); :}
                 | STATEMENT_LIST:sl STATEMENT:s {: RESULT = sl; RESULT.add(s); :};

STATEMENT ::= ASSIGN_STATEMENT:as {: RESULT = as; :}
            | BASIC_STATEMENT:bs {: RESULT = bs; :}
            | CONDITIONAL_STATEMENT:cs {: RESULT = cs; :}
            
            | WHILE_STATEMENT:ws SEP {: RESULT = ws; :}
            | FUNCTION_STATEMENT:fs SEP {: RESULT = fs; :}
            | ARITHMETIC_STATEMENT:as {: RESULT = as; :};

BASIC_STATEMENT ::= IDENTIFIER:i {: RESULT = new InstructionGetVariable(i); :}
                  | NUMBER:n {: RESULT = InstructionConstant.number(n); :}
                  | STRING:s {: RESULT = InstructionConstant.string(s); :}
                  | TRUE {: RESULT = InstructionConstant.bool(true); :}
                  | FALSE {: RESULT = InstructionConstant.bool(false); :}
                  | IF_STATEMENT:is {: RESULT = is; :}
                  | FUNCTION_CALL_STATEMENT:fcs {: RESULT = fcs; :};

ASSIGN_STATEMENT ::= IDENTIFIER:i ASSIGN BASIC_STATEMENT:bs {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN,  bs); :}
                   | IDENTIFIER:i ASSIGN ARITHMETIC_STATEMENT:as {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN,  as); :}
                   | IDENTIFIER:i ASSIGN NEGATE_STATEMENT:ns {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN,  ns); :}
                   | IDENTIFIER:i ASSIGN_PLUS NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN_PLUS,  InstructionConstant.number(n)); :}
                   | IDENTIFIER:i ASSIGN_MINUS NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN_MINUS,  InstructionConstant.number(n)); :}
                   | IDENTIFIER:i ASSIGN_MUL NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN_MUL,  InstructionConstant.number(n)); :}
                   | IDENTIFIER:i ASSIGN_DIVIDE NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN_DIVIDE,  InstructionConstant.number(n)); :};

IF_STATEMENT ::= IF CONDITIONAL_STATEMENT:cs TERMINATOR BASIC_STATEMENT:bs {: RESULT = new InstructionIfElseStatement(cs, bs, null); :};
//                | IF CONDITIONAL_STATEMENT:cs TERMINATOR BASIC_STATEMENT:bs ELSE_STATEMENT:es {: RESULT = new InstructionIfElseStatement(cs, bs, es); :};
// ELSE_STATEMENT ::= ELSE TERMINATOR BASIC_STATEMENT:bs {: RESULT = bs; :};

CONDITIONAL_STATEMENT ::= BASIC_STATEMENT:bsl EQUAL BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.EQUAL, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl NOT_EQUAL BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.NOT_EQUAL, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl LESS_THAN BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.LESS_THAN, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl GREATER BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.GREATER, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl LESS_EQUAL BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.LESS_EQUAL, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl GREATER_EQUAL BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.GREATER_EQUAL, bsl, bsr); :};

WHILE_STATEMENT ::= WHILE CONDITIONAL_STATEMENT:cs TERMINATOR ARGUMENT_LIST:al {: RESULT = new InstructionWhileStatement(cs, al); :};

FUNCTION_STATEMENT ::= IDENTIFIER:i ASSIGN FUNC PARAMETER_LIST:pl TERMINATOR STATEMENT:s {: RESULT = new InstructionFuncStatement(i, pl, s); :};
PARAMETER_LIST ::= {: RESULT = new ArrayList<String>(); :}
                 | IDENTIFIER:i {: RESULT = new ArrayList<String>(Arrays.asList(i)); :}
                 | IDENTIFIER:i SEPARATOR PARAMETER_LIST:pl {: RESULT = new ArrayList<String>(Arrays.asList(i)); RESULT.addAll(pl); :};

FUNCTION_CALL_STATEMENT ::= IDENTIFIER:i BRACKETS_LEFT ARGUMENT_LIST:al BRACKETS_RIGHT {: RESULT = new InstructionFuncCallStatement(i, al); :};
ARGUMENT_LIST ::= {: RESULT = new ArrayList<Instruction>(); :}
                | BASIC_STATEMENT:bs {: RESULT = new ArrayList<Instruction>(Arrays.asList(bs)); :}
                | BASIC_STATEMENT:bs SEPARATOR ARGUMENT_LIST:al {: RESULT = new ArrayList<Instruction>(Arrays.asList(bs)); RESULT.addAll(al); :};


ARITHMETIC_STATEMENT ::= BASIC_STATEMENT:bsl PLUS BASIC_STATEMENT:bsr {: RESULT = new InstructionBinaryOperation(BinaryOperator.PLUS, bsl, bsr); :}
                       | BASIC_STATEMENT:bsl MINUS BASIC_STATEMENT:bsr {: RESULT = new InstructionBinaryOperation(BinaryOperator.MINUS, bsl, bsr); :}
                       | BASIC_STATEMENT:bsl MINUS NEGATE_STATEMENT:nsr {: RESULT = new InstructionBinaryOperation(BinaryOperator.MINUS, bsl, nsr); :}
                       | BASIC_STATEMENT:bsl MUL BASIC_STATEMENT:bsr {: RESULT = new InstructionBinaryOperation(BinaryOperator.MUL, bsl, bsr); :}
                       | BASIC_STATEMENT:bsl DIV BASIC_STATEMENT:bsr {: RESULT = new InstructionBinaryOperation(BinaryOperator.DIV, bsl, bsr); :}
                       | BASIC_STATEMENT:bsl MOD BASIC_STATEMENT:bsr {: RESULT = new InstructionBinaryOperation(BinaryOperator.MOD, bsl, bsr); :}
                       | BASIC_STATEMENT:bsl POW BASIC_STATEMENT:bsr {: RESULT = new InstructionBinaryOperation(BinaryOperator.POW, bsl, bsr); :};

NEGATE_STATEMENT ::= MINUS BASIC_STATEMENT:bs {: RESULT = new InstructionNegate(bs); :};

END ::= 
     |  SEP
     ;
