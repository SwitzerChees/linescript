package ch.ffhs.pm.fac.parser;

import java.util.ArrayList;
import java.util.Arrays;
import java_cup.runtime.*;
import ch.ffhs.pm.fac.instr.*;

terminal EQUAL, NOT_EQUAL, LESS_THAN, GREATER, LESS_EQUAL, GREATER_EQUAL;
terminal ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_MUL, ASSIGN_DIVIDE;
terminal IF, ELSE, FUNC, WHILE, TERMINATOR, SEPARATOR, TRUE, FALSE, SEP;
terminal BRACKETS_LEFT, BRACKETS_RIGHT;

terminal String NUMBER;
terminal String STRING;
terminal String IDENTIFIER;

non terminal Instruction SCRIPT;
non terminal END;

non terminal ArrayList<Instruction> STATEMENT_LIST;
non terminal ArrayList<String> PARAMETER_LIST;
non terminal ArrayList<Instruction> ARGUMENT_LIST;
non terminal Instruction STATEMENT, ASSIGN_STATEMENT, BASIC_STATEMENT;
non terminal Instruction IF_STATEMENT, ELSE_STATEMENT, CONDITIONAL_STATEMENT, WHILE_STATEMENT;
non terminal Instruction FUNCTION_STATEMENT, FUNCTION_CALL_STATEMENT;

start with SCRIPT;
      
SCRIPT ::= STATEMENT_LIST:sl STATEMENT:s END {: RESULT = new InstructionScript(sl, s); :};
               
STATEMENT_LIST ::= {: RESULT = new ArrayList<Instruction>(); :}
                 | STATEMENT_LIST:sl STATEMENT:s {: RESULT = sl; RESULT.add(s); :};

STATEMENT ::= ASSIGN_STATEMENT:as {: RESULT = as; :}
            | BASIC_STATEMENT:bs {: RESULT = bs; :}
            | CONDITIONAL_STATEMENT:cs {: RESULT = cs; :}
            | IF_STATEMENT:is SEP {: RESULT = is; :}
            | WHILE_STATEMENT:ws SEP {: RESULT = ws; :}
            | FUNCTION_STATEMENT:fs SEP {: RESULT = fs; :}
            | FUNCTION_CALL_STATEMENT:fcs {: RESULT = fcs; :};

BASIC_STATEMENT ::= IDENTIFIER:i {: RESULT = new InstructionGetVariable(i); :}
                   |  NUMBER:n {: RESULT = InstructionConstant.number(n); :}
                   |  STRING:s {: RESULT = InstructionConstant.string(s); :}
                   |  TRUE {: RESULT = InstructionConstant.bool(true); :}
                   |  FALSE {: RESULT = InstructionConstant.bool(false); :};

ASSIGN_STATEMENT ::= IDENTIFIER:i ASSIGN NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN,  InstructionConstant.number(n)); :}
                   | IDENTIFIER:i ASSIGN STRING:s {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN,  InstructionConstant.string(s)); :}
                   | IDENTIFIER:i ASSIGN TRUE {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN,  InstructionConstant.bool(true)); :}
                   | IDENTIFIER:i ASSIGN FALSE {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN,  InstructionConstant.bool(false)); :}
                   | IDENTIFIER:i ASSIGN_PLUS NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN_PLUS,  InstructionConstant.number(n)); :}
                   | IDENTIFIER:i ASSIGN_MINUS NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN_MINUS,  InstructionConstant.number(n)); :}
                   | IDENTIFIER:i ASSIGN_MUL NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN_MUL,  InstructionConstant.number(n)); :}
                   | IDENTIFIER:i ASSIGN_DIVIDE NUMBER:n {: RESULT = new InstructionSetVariable(i, AssignOperator.ASSIGN_DIVIDE,  InstructionConstant.number(n)); :};

IF_STATEMENT ::= IF CONDITIONAL_STATEMENT:cs TERMINATOR STATEMENT:s {: RESULT = new InstructionIfElseStatement(cs, s, null); :}
               | IF CONDITIONAL_STATEMENT:cs TERMINATOR STATEMENT:s ELSE_STATEMENT:es {: RESULT = new InstructionIfElseStatement(cs, s, es); :};
ELSE_STATEMENT ::= ELSE TERMINATOR STATEMENT:s {: RESULT = s; :};

CONDITIONAL_STATEMENT ::= BASIC_STATEMENT:bsl EQUAL BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.EQUAL, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl NOT_EQUAL BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.NOT_EQUAL, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl LESS_THAN BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.LESS_THAN, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl GREATER BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.GREATER, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl LESS_EQUAL BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.LESS_EQUAL, bsl, bsr); :}
                        | BASIC_STATEMENT:bsl GREATER_EQUAL BASIC_STATEMENT:bsr {: RESULT = new InstructionConditionalStatement(ConditionalExpression.GREATER_EQUAL, bsl, bsr); :};

WHILE_STATEMENT ::= WHILE CONDITIONAL_STATEMENT:cs TERMINATOR STATEMENT_LIST:sl {: RESULT = new InstructionWhileStatement(cs, sl); :};

FUNCTION_STATEMENT ::= FUNC IDENTIFIER:i PARAMETER_LIST:pl TERMINATOR STATEMENT:s {: RESULT = new InstructionFuncStatement(i, pl, s); :};
PARAMETER_LIST ::= IDENTIFIER:i {: RESULT = new ArrayList<String>(Arrays.asList(i)); :}
                 | IDENTIFIER:i SEPARATOR PARAMETER_LIST:pl {: RESULT = new ArrayList<String>(Arrays.asList(i)); RESULT.addAll(pl); :};

FUNCTION_CALL_STATEMENT ::= IDENTIFIER:i BRACKETS_LEFT ARGUMENT_LIST:al BRACKETS_RIGHT {: RESULT = new InstructionFuncCallStatement(i, al); :};
ARGUMENT_LIST ::= BASIC_STATEMENT:bs {: RESULT = new ArrayList<Instruction>(Arrays.asList(bs)); :}
                | BASIC_STATEMENT:bs SEPARATOR ARGUMENT_LIST:al {: RESULT = new ArrayList<Instruction>(Arrays.asList(bs)); RESULT.addAll(al); :};

END ::= 
     |  SEP
     ;

// ASSIGNMENT ::= IDENTIFIER:i ASSIGN SUM:s SEP
//                 {: RESULT = new InstructionSetVariable(i, s); :}
//               ;
           
       
// SUM ::= PRODUCT:p
//         {: RESULT = p; :}
//      |  MINUS PRODUCT:p
//         {: RESULT = new InstructionNegate(p); :}
//      |  SUM:s PLUS PRODUCT:p
//         {: RESULT = new InstructionBinaryOperation(BinaryOperator.PLUS, s, p); :}
//      |  SUM:s MINUS PRODUCT:p
//         {: RESULT = new InstructionBinaryOperation(BinaryOperator.MINUS, s, p); :}
//      ;
     
// PRODUCT ::= POWER:pp
//             {: RESULT = pp; :}
//          |  PRODUCT:p TIMES POWER:pp
//             {: RESULT = new InstructionBinaryOperation(BinaryOperator.TIMES, p, pp); :}
//          |  PRODUCT:p DIV POWER:pp
//             {: RESULT = new InstructionBinaryOperation(BinaryOperator.DIV, p, pp); :}
//          |  PRODUCT:p MOD POWER:pp
//             {: RESULT = new InstructionBinaryOperation(BinaryOperator.MOD, p, pp); :}
//          ;
                    
// POWER ::= SIMPLE_TERM:st
//           {: RESULT = st; :}
//         | SIMPLE_TERM:st POW POWER:pp
//           {: RESULT = new InstructionBinaryOperation(BinaryOperator.POW, st, pp); :}
//         ;
        
// SIMPLE_TERM ::= IDENTIFIER:i
//                 {: RESULT = new InstructionGetVariable(i); :}
//              |  NUMBER:n
//                 {: RESULT = InstructionConstant.integer(n); :}
//              |  LPAR SUM:s RPAR
//                 {: RESULT = s; :}
//              ;    
   